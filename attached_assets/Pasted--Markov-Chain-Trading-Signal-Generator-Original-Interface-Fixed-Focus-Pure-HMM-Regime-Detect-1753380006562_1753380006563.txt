"""
Markov Chain Trading Signal Generator - Original Interface Fixed
Focus: Pure HMM Regime Detection + User-Controlled Position Sizing
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from datetime import datetime, timedelta
import yfinance as yf
from sklearn.mixture import GaussianMixture
from sklearn.preprocessing import StandardScaler
import warnings
warnings.filterwarnings('ignore')

# Page configuration
st.set_page_config(
    page_title="Markov Chain Trading Signals",
    page_icon="üîÆ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS
st.markdown("""
<style>
    .main-header {
        font-size: 3rem;
        font-weight: bold;
        text-align: center;
        margin-bottom: 2rem;
        background: linear-gradient(90deg, #1f4e79, #2e8b57);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .signal-box {
        padding: 2rem;
        border-radius: 15px;
        text-align: center;
        margin: 1rem 0;
        border: 3px solid;
    }
    
    .buy-signal {
        background: linear-gradient(135deg, #d4edda, #c3e6cb);
        border-color: #28a745;
        color: #155724;
    }
    
    .sell-signal {
        background: linear-gradient(135deg, #f8d7da, #f5c6cb);
        border-color: #dc3545;
        color: #721c24;
    }
    
    .hold-signal {
        background: linear-gradient(135deg, #fff3cd, #ffeaa7);
        border-color: #ffc107;
        color: #856404;
    }
    
    .regime-card {
        background: #f8f9fa;
        padding: 1.5rem;
        border-radius: 10px;
        border-left: 5px solid #007bff;
        margin: 1rem 0;
    }
    
    .strength-meter {
        font-size: 1.5rem;
        margin: 1rem 0;
    }
</style>
""", unsafe_allow_html=True)

class HMMSignalGenerator:
    """HMM Signal Generator with tolist() error fixed"""
    
    def __init__(self, n_states=3):
        self.n_states = n_states
        self.model = None
        self.scaler = StandardScaler()
        self.regime_names = {0: 'Bear', 1: 'Sideways', 2: 'Bull'}
        self.regime_colors = {0: '#dc3545', 1: '#ffc107', 2: '#28a745'}
        self.regime_icons = {0: 'üìâ', 1: '‚û°Ô∏è', 2: 'üìà'}
    
    def prepare_features(self, data):
        """Feature preparation with tolist() error fixed"""
        if len(data) < 60:
            raise ValueError("Need at least 60 days of data")
        
        # Extract price and volume as Series (not DataFrame)
        close_prices = data['Close']
        volume = data['Volume']
        
        # Calculate basic features
        returns = close_prices.pct_change()
        volatility = returns.rolling(window=20, min_periods=1).std()
        
        # Volume features
        volume_ma = volume.rolling(window=20, min_periods=1).mean()
        volume_ratio = volume / volume_ma
        
        # Momentum
        momentum = close_prices.pct_change(10)
        
        # Simple RSI
        rsi = self.calculate_rsi(close_prices)
        
        # Create features DataFrame
        features = pd.DataFrame({
            'returns': returns,
            'volatility': volatility,
            'volume_ratio': volume_ratio,
            'momentum': momentum,
            'rsi': rsi
        })
        
        # Clean the data
        features = features.fillna(0)
        features = features.replace([np.inf, -np.inf], 0)
        
        # Remove first 30 rows for stability
        features_clean = features.iloc[30:].copy()
        
        if len(features_clean) < 50:
            raise ValueError("Insufficient clean data")
        
        return features_clean
    
    def calculate_rsi(self, prices):
        """RSI calculation - tolist() error fixed"""
        # Convert Series to numpy array first, then to list
        if hasattr(prices, 'values'):
            price_array = prices.values.flatten()  # Flatten to 1D
        else:
            price_array = np.array(prices).flatten()
        
        price_list = price_array.tolist()  # Now convert to list safely
        
        if len(price_list) < 15:
            return pd.Series([50] * len(price_list), index=prices.index)
        
        # Calculate RSI using the list
        rsi_values = []
        period = 14
        
        for i in range(len(price_list)):
            if i < period:
                rsi_values.append(50)
            else:
                # Calculate price changes
                changes = []
                for j in range(i - period + 1, i + 1):
                    if j > 0:
                        changes.append(price_list[j] - price_list[j-1])
                
                if not changes:
                    rsi_values.append(50)
                    continue
                
                # Gains and losses
                gains = [c for c in changes if c > 0]
                losses = [-c for c in changes if c < 0]
                
                avg_gain = sum(gains) / len(changes) if gains else 0
                avg_loss = sum(losses) / len(changes) if losses else 0
                
                if avg_loss == 0:
                    rsi_values.append(100)
                else:
                    rs = avg_gain / avg_loss
                    rsi = 100 - (100 / (1 + rs))
                    rsi_values.append(rsi)
        
        return pd.Series(rsi_values, index=prices.index)
    
    def fit_model(self, features):
        """Fit HMM model"""
        try:
            # Convert to numpy array safely
            feature_values = features.values
            
            # Clean any remaining issues
            feature_values = np.nan_to_num(feature_values, nan=0, posinf=1, neginf=-1)
            
            # Scale features
            scaled_features = self.scaler.fit_transform(feature_values)
            
            # Fit model
            self.model = GaussianMixture(
                n_components=self.n_states,
                covariance_type='diag',
                random_state=42,
                max_iter=100
            )
            
            self.model.fit(scaled_features)
            
            # Get predictions
            states = self.model.predict(scaled_features)
            probabilities = self.model.predict_proba(scaled_features)
            
            # Sort regimes by average return
            regime_returns = {}
            for regime in range(self.n_states):
                mask = states == regime
                if np.sum(mask) > 0:
                    regime_returns[regime] = features.loc[features.index[mask], 'returns'].mean()
                else:
                    regime_returns[regime] = 0
            
            # Create mapping: Bear=0, Sideways=1, Bull=2
            sorted_regimes = sorted(regime_returns.items(), key=lambda x: x[1])
            regime_mapping = {old: new for new, (old, _) in enumerate(sorted_regimes)}
            
            # Remap states
            remapped_states = np.array([regime_mapping[state] for state in states])
            
            # Remap probabilities
            remapped_probs = np.zeros_like(probabilities)
            for old_regime, new_regime in regime_mapping.items():
                remapped_probs[:, new_regime] = probabilities[:, old_regime]
            
            return remapped_states, remapped_probs
            
        except Exception as e:
            raise ValueError(f"Model fitting failed: {str(e)}")
    
    def analyze_regimes(self, features, states, probabilities):
        """Analyze regime characteristics"""
        regime_stats = {}
        
        for regime in range(self.n_states):
            mask = states == regime
            if np.sum(mask) > 0:
                regime_features = features.iloc[mask]
                
                regime_stats[regime] = {
                    'name': self.regime_names[regime],
                    'icon': self.regime_icons[regime],
                    'color': self.regime_colors[regime],
                    'days': int(np.sum(mask)),
                    'percentage': float(np.sum(mask) / len(states) * 100),
                    'avg_return': float(regime_features['returns'].mean() * 100),
                    'volatility': float(regime_features['returns'].std() * 100),
                    'persistence': self.calculate_persistence(states, regime)
                }
        
        return regime_stats
    
    def calculate_persistence(self, states, regime):
        """Calculate regime persistence"""
        if len(states) < 2:
            return 0.0
        
        same_transitions = 0
        total_regime_days = 0
        
        for i in range(1, len(states)):
            if states[i-1] == regime:
                total_regime_days += 1
                if states[i] == regime:
                    same_transitions += 1
        
        return (same_transitions / total_regime_days * 100) if total_regime_days > 0 else 0.0
    
    def generate_signal(self, current_regime, confidence, regime_stats):
        """Generate trading signal"""
        regime_name = self.regime_names[current_regime]
        
        if confidence >= 0.7:
            if regime_name == 'Bull':
                signal = 'BUY'
                strength = min(10, max(6, int(confidence * 12)))
            elif regime_name == 'Bear':
                signal = 'SELL'
                strength = min(10, max(6, int(confidence * 12)))
            else:
                signal = 'HOLD'
                strength = max(3, int(confidence * 8))
        else:
            signal = 'HOLD'
            strength = max(1, int(confidence * 6))
        
        return {
            'signal': signal,
            'strength': strength,
            'regime': regime_name,
            'confidence': confidence * 100,
            'regime_stats': regime_stats.get(current_regime, {})
        }

def main():
    # Header
    st.markdown('<h1 class="main-header">üîÆ Markov Chain Trading Signals</h1>', unsafe_allow_html=True)
    
    st.markdown("""
    <div class="regime-card">
    <strong>üéØ Pure HMM Signal Generation</strong><br>
    Advanced regime detection using Hidden Markov Models. You control position sizing and risk management 
    based on high-quality market regime signals.
    </div>
    """, unsafe_allow_html=True)
    
    # Sidebar inputs
    st.sidebar.header("üìä Analysis Settings")
    
    symbol = st.sidebar.text_input(
        "Stock Symbol:",
        value="SOFI",
        help="Enter any valid stock ticker"
    ).upper()
    
    lookback_days = st.sidebar.slider(
        "Analysis Period (Days):",
        min_value=100,
        max_value=800,
        value=252,
        help="Number of trading days to analyze"
    )
    
    confidence_threshold = st.sidebar.slider(
        "Signal Confidence Threshold:",
        min_value=0.5,
        max_value=0.9,
        value=0.7,
        step=0.05,
        help="Minimum confidence required for BUY/SELL signals"
    )
    
    # Analysis button
    if st.sidebar.button("üöÄ Generate Signal", type="primary"):
        try:
            with st.spinner(f"Analyzing {symbol} market regimes..."):
                # Download data
                end_date = datetime.now()
                start_date = end_date - timedelta(days=int(lookback_days * 1.8))
                
                data = yf.download(symbol, start=start_date, end=end_date, progress=False)
                
                if data.empty:
                    st.error(f"‚ùå No data available for {symbol}")
                    return
                
                if len(data) < 100:
                    st.error(f"‚ùå Insufficient data for {symbol}. Need at least 100 days.")
                    return
                
                # Initialize HMM
                hmm = HMMSignalGenerator()
                
                # Prepare features
                features = hmm.prepare_features(data)
                
                # Fit model and get predictions
                states, probabilities = hmm.fit_model(features)
                
                # Get current state
                current_regime = states[-1]
                current_confidence = probabilities[-1].max()
                
                # Analyze regimes
                regime_stats = hmm.analyze_regimes(features, states, probabilities)
                
                # Generate signal
                signal_data = hmm.generate_signal(current_regime, current_confidence, regime_stats)
                
                # Display results
                display_results(symbol, signal_data, regime_stats, data, features, states, probabilities, confidence_threshold)
                
        except Exception as e:
            st.error(f"‚ùå Error: {str(e)}")
            st.info("üí° Try using AAPL or reduce the analysis period to 200 days")

def display_results(symbol, signal_data, regime_stats, data, features, states, probabilities, confidence_threshold):
    """Display comprehensive analysis results - ORIGINAL INTERFACE"""
    
    # Main signal display
    signal = signal_data['signal']
    strength = signal_data['strength']
    regime = signal_data['regime']
    confidence = signal_data['confidence']
    
    # Signal box styling
    if signal == 'BUY':
        signal_class = 'buy-signal'
        signal_icon = 'üü¢'
    elif signal == 'SELL':
        signal_class = 'sell-signal'
        signal_icon = 'üî¥'
    else:
        signal_class = 'hold-signal'
        signal_icon = 'üü°'
    
    st.markdown(f"""
    <div class="signal-box {signal_class}">
        <h2>{signal_icon} {signal} SIGNAL</h2>
        <h3>{regime} Market Regime</h3>
        <p><strong>Confidence:</strong> {confidence:.1f}%</p>
        <div class="strength-meter">
            Signal Strength: {'‚ñà' * strength}{'‚ñë' * (10-strength)} ({strength}/10)
        </div>
    </div>
    """, unsafe_allow_html=True)
    
    # Current regime details
    current_regime_stats = signal_data['regime_stats']
    if current_regime_stats:
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric(
                "Avg Daily Return",
                f"{current_regime_stats.get('avg_return', 0):.2f}%",
                help="Average daily return in current regime"
            )
        
        with col2:
            st.metric(
                "Volatility",
                f"{current_regime_stats.get('volatility', 0):.1f}%",
                help="Daily volatility in current regime"
            )
        
        with col3:
            st.metric(
                "Persistence",
                f"{current_regime_stats.get('persistence', 0):.1f}%",
                help="Probability regime continues tomorrow"
            )
        
        with col4:
            st.metric(
                "Days in Regime",
                f"{current_regime_stats.get('days', 0)}",
                help="Total days in this regime historically"
            )
    
    # Regime statistics
    st.header("üìä Regime Analysis")
    
    regime_data = []
    for regime_id, stats in regime_stats.items():
        regime_data.append({
            'Regime': f"{stats['icon']} {stats['name']}",
            'Days': stats['days'],
            'Percentage': f"{stats['percentage']:.1f}%",
            'Avg Return': f"{stats['avg_return']:.2f}%",
            'Volatility': f"{stats['volatility']:.1f}%",
            'Persistence': f"{stats['persistence']:.1f}%"
        })
    
    regime_df = pd.DataFrame(regime_data)
    st.dataframe(regime_df, use_container_width=True)
    
    # Position sizing guidance
    st.header("üí° Position Sizing Guidance")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("""
        <div class="regime-card">
        <h4>üéØ Suggested Position Sizes</h4>
        <ul>
        <li><strong>Conservative:</strong> 2-5% of portfolio</li>
        <li><strong>Moderate:</strong> 5-10% of portfolio</li>
        <li><strong>Aggressive:</strong> 10-20% of portfolio</li>
        </ul>
        <p><em>Adjust based on your risk tolerance and the signal strength above.</em></p>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        persistence_rate = current_regime_stats.get('persistence', 0) if current_regime_stats else 0
        st.markdown(f"""
        <div class="regime-card">
        <h4>‚ö†Ô∏è Risk Management</h4>
        <ul>
        <li><strong>Stop Loss:</strong> Set based on your pain threshold</li>
        <li><strong>Take Profit:</strong> Consider regime persistence rate</li>
        <li><strong>Review:</strong> Check weekly for regime changes</li>
        <li><strong>Current Persistence:</strong> {persistence_rate:.1f}%</li>
        </ul>
        </div>
        """, unsafe_allow_html=True)
    
    # Price chart with regime overlay
    st.header("üìà Price Chart with Regime Detection")
    
    try:
        # Get recent data for chart
        chart_data = data.loc[features.index].tail(200)
        chart_states = states[-len(chart_data):]
        
        fig = go.Figure()
        
        # Add price line
        fig.add_trace(go.Scatter(
            x=chart_data.index,
            y=chart_data['Close'],
            mode='lines',
            name=f'{symbol} Price',
            line=dict(color='black', width=2)
        ))
        
        # Add regime background colors
        regime_colors = {0: 'rgba(220, 53, 69, 0.2)', 1: 'rgba(255, 193, 7, 0.2)', 2: 'rgba(40, 167, 69, 0.2)'}
        
        if len(chart_states) > 0:
            current_regime = chart_states[0]
            regime_start = 0
            
            for i in range(1, len(chart_states)):
                if chart_states[i] != current_regime or i == len(chart_states) - 1:
                    end_idx = i - 1 if i < len(chart_states) else i - 1
                    
                    fig.add_shape(
                        type="rect",
                        x0=chart_data.index[regime_start],
                        x1=chart_data.index[end_idx],
                        y0=chart_data['Close'].min() * 0.95,
                        y1=chart_data['Close'].max() * 1.05,
                        fillcolor=regime_colors.get(current_regime, 'rgba(128, 128, 128, 0.2)'),
                        layer="below",
                        line_width=0,
                    )
                    
                    regime_start = i
                    current_regime = chart_states[i] if i < len(chart_states) else current_regime
        
        fig.update_layout(
            title=f"{symbol} Price with Market Regimes",
            xaxis_title="Date",
            yaxis_title="Price ($)",
            hovermode='x unified',
            template='plotly_white',
            height=500
        )
        
        st.plotly_chart(fig, use_container_width=True)
        
    except Exception as e:
        st.warning(f"Chart display temporarily unavailable: {str(e)}")
    
    # Regime transition matrix
    st.header("üîÑ Regime Transition Analysis")
    
    try:
        # Calculate transition matrix
        transition_matrix = np.zeros((3, 3))
        for i in range(1, len(states)):
            transition_matrix[states[i-1], states[i]] += 1
        
        # Normalize
        for i in range(3):
            if transition_matrix[i].sum() > 0:
                transition_matrix[i] = transition_matrix[i] / transition_matrix[i].sum()
        
        # Create heatmap
        regime_labels = ['üìâ Bear', '‚û°Ô∏è Sideways', 'üìà Bull']
        
        fig_transition = px.imshow(
            transition_matrix,
            labels=dict(x="To Regime", y="From Regime", color="Probability"),
            x=regime_labels,
            y=regime_labels,
            color_continuous_scale='RdYlBu_r',
            title="Regime Transition Probabilities"
        )
        
        # Add text annotations
        for i in range(3):
            for j in range(3):
                fig_transition.add_annotation(
                    x=j, y=i,
                    text=f"{transition_matrix[i,j]:.2f}",
                    showarrow=False,
                    font=dict(color="white" if transition_matrix[i,j] > 0.5 else "black")
                )
        
        st.plotly_chart(fig_transition, use_container_width=True)
        
    except Exception as e:
        st.info("Transition matrix temporarily unavailable")
    
    # Footer
    st.markdown("---")
    st.markdown(f"""
    <div style="text-align: center; color: #666;">
    <p>üîÆ Analysis completed for {symbol} ‚Ä¢ Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M')} ‚Ä¢ 
    <strong>Remember:</strong> You control position sizing and risk management</p>
    </div>
    """, unsafe_allow_html=True)

if __name__ == "__main__":
    main()